"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lintFile = void 0;
var typescript_1 = require("typescript");
var types_1 = require("./types");
// Determines if this is a test file.
var isTestFile = function (file) {
    return file.fileName.endsWith("_test.ts") ||
        file.fileName.endsWith("_test.tsx");
};
// Determines whether this is a ++var, --var, var++, or var--.
var isVariableIncDec = function (expr) {
    if (expr.kind === typescript_1.SyntaxKind.PrefixUnaryExpression) {
        if ((0, types_1.assertPrefixUnaryExpr)(expr)) {
            return (expr.operator === typescript_1.SyntaxKind.PlusPlusToken ||
                expr.operator === typescript_1.SyntaxKind.MinusMinusToken) &&
                expr.operand.kind === typescript_1.SyntaxKind.Identifier;
        }
    }
    else if (expr.kind === typescript_1.SyntaxKind.PostfixUnaryExpression) {
        if ((0, types_1.assertPostfixUnaryExpr)(expr)) {
            return (expr.operator === typescript_1.SyntaxKind.PlusPlusToken ||
                expr.operator === typescript_1.SyntaxKind.MinusMinusToken) &&
                expr.operand.kind === typescript_1.SyntaxKind.Identifier;
        }
    }
    return false;
};
/**
 * Lints the contents of the given file.
 * @param file File to lint
 */
var lintFile = function (file) {
    file.root.forEachChild(function (node) { return lintTopLevelNode(file, node); });
};
exports.lintFile = lintFile;
// Lints the given child of the source file.
var lintTopLevelNode = function (file, node) {
    switch (node.kind) {
        case typescript_1.SyntaxKind.ImportDeclaration:
            if ((0, types_1.assertImportDecl)(node)) {
                lintImportDecl(file, node);
            }
            break;
        case typescript_1.SyntaxKind.EndOfFileToken:
            // OK
            break;
        case typescript_1.SyntaxKind.TypeAliasDeclaration:
            if ((0, types_1.assertTypeAliasDecl)(node)) {
                lintTypeAliasDecl(file, node);
            }
            break;
        case typescript_1.SyntaxKind.VariableStatement:
            if ((0, types_1.assertVariableStmt)(node)) {
                lintVariableStmt(file, node, true, false);
            }
            break;
        case typescript_1.SyntaxKind.ExpressionStatement:
            if ((0, types_1.assertExpressionStmt)(node)) {
                lintExpressionStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.IfStatement:
            if ((0, types_1.assertIfStmt)(node)) {
                lintIfStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.SwitchStatement:
            if ((0, types_1.assertSwitchStmt)(node)) {
                lintSwitchStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.WhileStatement:
            if ((0, types_1.assertWhileStmt)(node)) {
                lintWhileStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.ForStatement:
            if ((0, types_1.assertForStmt)(node)) {
                lintForStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.ForOfStatement:
            if ((0, types_1.assertForOfStmt)(node)) {
                lintForOfStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.ReturnStatement:
            if ((0, types_1.assertReturnStmt)(node)) {
                lintReturnStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.ThrowStatement:
            if ((0, types_1.assertThrowStmt)(node)) {
                lintThrowStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.TryStatement:
            if ((0, types_1.assertTryStmt)(node)) {
                lintTryStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.DoStatement:
            if ((0, types_1.assertDoStmt)(node)) {
                file.error("do statements are not allowed", node.statement.pos - 2);
            }
            break;
        case typescript_1.SyntaxKind.ForInStatement:
            if ((0, types_1.assertForInStmt)(node)) {
                file.error("for-in statements are not allowed", node.expression.pos, node.expression.end);
            }
            break;
        case typescript_1.SyntaxKind.WithStatement:
            if ((0, types_1.assertWithStmt)(node)) {
                file.error("with statements are not allowed", node.expression.pos, node.expression.end);
            }
            break;
        case typescript_1.SyntaxKind.LabeledStatement:
            if ((0, types_1.assertLabeledStmt)(node)) {
                file.error("labeled statements are not allowed", node.label.end - 1);
            }
            break;
        case typescript_1.SyntaxKind.Block:
            if ((0, types_1.assertBlock)(node)) {
                lintBlock(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.FunctionDeclaration:
            if ((0, types_1.assertFunctionDecl)(node)) {
                if (node.name === undefined) {
                    file.error("incorrect syntax for a function declaration", node.parameters.pos);
                }
                else {
                    file.error("incorrect syntax for a function declaration", node.name.pos);
                }
            }
            break;
        case typescript_1.SyntaxKind.InterfaceDeclaration:
            if ((0, types_1.assertInterfaceDecl)(node)) {
                lintInterfaceDecl(file, node);
            }
            break;
        case typescript_1.SyntaxKind.ClassDeclaration:
            if ((0, types_1.assertClassDecl)(node)) {
                lintClassDecl(file, node);
            }
            break;
        default:
            file.error("unexpected top-level node type: ".concat(typescript_1.SyntaxKind[node.kind]), node.pos + 1);
            break;
    }
};
// Set of imports that can be used with "import name as 'name'" syntax.
var allowedNameImports = new Set(["express", "body-parser", "react"]);
// Set of imports that can be used with "import * from name as 'name'" syntax.
var allowedStarImports = new Set(["assert", "node-mocks-http"]);
/** Determines if the given name could be an image file. */
var isImageName = function (name) {
    name = name.toLowerCase();
    return name.endsWith(".png") || name.endsWith(".jpg") || name.endsWith(".jpeg") ||
        name.endsWith(".gif") || name.endsWith(".svg");
};
// Performs linting of an import statement.
var lintImportDecl = function (file, node) {
    if (node.importClause === undefined) {
        // OK (this is probably a CSS import)
    }
    else {
        if (node.importClause.namedBindings !== undefined &&
            node.importClause.namedBindings.kind === typescript_1.SyntaxKind.NamedImports) {
            // OK (regular import)
        }
        else if (node.importClause.name !== undefined &&
            node.importClause.name.kind === typescript_1.SyntaxKind.Identifier &&
            node.moduleSpecifier !== undefined &&
            node.moduleSpecifier.kind === typescript_1.SyntaxKind.StringLiteral) {
            if ((0, types_1.assertStringLiteral)(node.moduleSpecifier)) {
                if (!allowedNameImports.has(node.moduleSpecifier.text) &&
                    !isImageName(node.moduleSpecifier.text)) {
                    file.error("unexpected import of ".concat(node.moduleSpecifier.text), node.importClause.pos);
                }
            }
        }
        else if (node.importClause.namedBindings !== undefined &&
            node.importClause.namedBindings.kind === typescript_1.SyntaxKind.NamespaceImport &&
            node.moduleSpecifier !== undefined &&
            node.moduleSpecifier.kind === typescript_1.SyntaxKind.StringLiteral) {
            if ((0, types_1.assertStringLiteral)(node.moduleSpecifier)) {
                if (!allowedStarImports.has(node.moduleSpecifier.text)) {
                    file.error("unexpected * import of ".concat(node.moduleSpecifier.text), node.importClause.pos);
                }
            }
        }
        else {
            file.error("unexpected import syntax", node.importClause.pos);
        }
    }
};
// Performs linting of a type alias declaration.
var lintTypeAliasDecl = function (file, node) {
    lintType(file, node.type, true);
};
// Performs linting of an interface declaration.
var lintInterfaceDecl = function (file, node) {
    var e_1, _a, e_2, _b;
    try {
        for (var _c = __values(node.members), _d = _c.next(); !_d.done; _d = _c.next()) {
            var member = _d.value;
            if (member.kind === typescript_1.SyntaxKind.PropertySignature) {
                if ((0, types_1.assertPropertySignature)(member)) {
                    if (member.type === undefined) {
                        file.error("field declaration is missing a type", member.name.end - 1);
                    }
                    else {
                        if (member.type.kind !== typescript_1.SyntaxKind.FunctionType) {
                            file.error("interfaces can only contain methods", member.name.end - 1);
                        }
                        else {
                            if ((0, types_1.assertFunctionType)(member.type)) {
                                try {
                                    for (var _e = (e_2 = void 0, __values(member.type.parameters)), _f = _e.next(); !_f.done; _f = _e.next()) {
                                        var param = _f.value;
                                        if (param.type === undefined) {
                                            file.error("parameter is missing a type", param.name.end - 1);
                                        }
                                        else {
                                            lintType(file, param.type);
                                        }
                                    }
                                }
                                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                                finally {
                                    try {
                                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                                    }
                                    finally { if (e_2) throw e_2.error; }
                                }
                                lintType(file, member.type.type);
                            }
                        }
                    }
                }
            }
            else if (member.kind === typescript_1.SyntaxKind.MethodSignature) {
                if ((0, types_1.assertMethodSignature)(member)) {
                    file.error("incorrect method declaration syntax", member.name.end - 1);
                }
            }
            else {
                file.error("unexpected interface member type: ".concat(typescript_1.SyntaxKind[member.kind]), member.pos + 1);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
};
// Performs linting of an class declaration.
var lintClassDecl = function (file, node) {
    var e_3, _a;
    var superclass = undefined;
    var interfaces = [];
    if (node.heritageClauses !== undefined) {
        try {
            for (var _b = __values(node.heritageClauses), _c = _b.next(); !_c.done; _c = _b.next()) {
                var herit = _c.value;
                if (herit.types.length === 1 &&
                    herit.types[0].expression.kind === typescript_1.SyntaxKind.Identifier &&
                    (0, types_1.assertIdentifier)(herit.types[0].expression)) {
                    if (herit.token === typescript_1.SyntaxKind.ExtendsKeyword) {
                        superclass = herit.types[0].expression.text;
                    }
                    else if (herit.token === typescript_1.SyntaxKind.ImplementsKeyword) {
                        interfaces.push(herit.types[0].expression.text);
                    }
                    else {
                        file.error("unexpected inheritance token: ".concat(typescript_1.SyntaxKind[herit.token]), herit.pos + 1);
                    }
                }
                else {
                    file.error("incorrect inheritance syntax", herit.pos + 1);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    }
    if (superclass === "Component") {
        lintComponentClass(file, node, interfaces);
    }
    else {
        lintAdtClass(file, node, superclass, interfaces);
    }
};
// Performs linting of a UI component.
var lintComponentClass = function (file, node, interfaces) {
    var e_4, _a;
    if (interfaces.length > 0) {
        file.error("components should not implement any interfaces", node.name !== undefined ? node.name.pos : node.pos + 1);
    }
    try {
        for (var _b = __values(node.members), _c = _b.next(); !_c.done; _c = _b.next()) {
            var member = _c.value;
            switch (member.kind) {
                case typescript_1.SyntaxKind.Constructor:
                    if ((0, types_1.assertConstructorDecl)(member)) {
                        lintConstructor(file, member);
                    }
                    break;
                case typescript_1.SyntaxKind.PropertyDeclaration:
                    if ((0, types_1.assertPropertyDecl)(member)) {
                        if (member.initializer !== undefined &&
                            member.initializer.kind === typescript_1.SyntaxKind.ArrowFunction &&
                            (0, types_1.assertArrowFunction)(member.initializer)) {
                            var name_1 = getName(member.name);
                            if (name_1 !== undefined) {
                                lintComponentMethodName(file, member.name, name_1);
                            }
                            else {
                                file.error("unexpected property name syntax: ".concat(typescript_1.SyntaxKind[member.name.kind]), member.name.end);
                            }
                            lintArrowFunction(file, member.initializer, false);
                        }
                        else {
                            file.error("fields are not allowed in components", member.name.end - 1);
                        }
                    }
                    break;
                case typescript_1.SyntaxKind.MethodDeclaration:
                    if ((0, types_1.assertMethodDecl)(member)) {
                        file.error("incorrect method declaration syntax", member.name.end - 1);
                    }
                    break;
                default:
                    file.error("unexpected class member type: ".concat(typescript_1.SyntaxKind[member.kind]), member.pos + 1);
                    break;
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_4) throw e_4.error; }
    }
};
// Set of allowed lifecycle methods.
var allowedLifeCycleMethods = new Set(["componentDidMount", "componentDidUpdate", "componentWillUnmount"]);
// Set of allowed HTML events.
// TODO: add more
var allowedEvents = new Set([
    "Click", "Change", "Timeout", "Focus", "Blur", "MouseEnter", "MouseLeave",
    "KeyDown", "KeyUp", "KeyPress", "Fetch", "Resp", "Response", "Json",
    "Error"
]);
// Performs linting of the name of a component method
var lintComponentMethodName = function (file, node, name) {
    var e_5, _a;
    if (name.startsWith("render") &&
        (name.length === 6 || name[6].toUpperCase() === name[6])) {
        // OK: render or render helper
    }
    else if (name.startsWith("get") &&
        name.length > 3 && name[3].toUpperCase() === name[3]) {
        // OK: getter function
    }
    else if (name.startsWith("set") &&
        name.length > 3 && name[3].toUpperCase() === name[3]) {
        // OK: setter function
    }
    else if (allowedLifeCycleMethods.has(name)) {
        // OK
    }
    else {
        if (!name.startsWith("do") || name.length < 3 ||
            name[2].toUpperCase() !== name[2]) {
            file.error("event handler method names must start with 'do'", node.end - 1);
        }
        else {
            try {
                for (var allowedEvents_1 = __values(allowedEvents), allowedEvents_1_1 = allowedEvents_1.next(); !allowedEvents_1_1.done; allowedEvents_1_1 = allowedEvents_1.next()) {
                    var evtName = allowedEvents_1_1.value;
                    if (name.endsWith(evtName)) {
                        return; // OK
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (allowedEvents_1_1 && !allowedEvents_1_1.done && (_a = allowedEvents_1.return)) _a.call(allowedEvents_1);
                }
                finally { if (e_5) throw e_5.error; }
            }
            file.error("event handler method names must end with an event name (e.g., Click)", node.end);
        }
    }
};
// Performs linting of a class that implements an ADT.
var lintAdtClass = function (file, node, superclass, interfaces) {
    var e_6, _a;
    if (node.modifiers !== undefined &&
        contains(node.modifiers, typescript_1.SyntaxKind.ExportKeyword)) {
        file.error("classes cannot be exported", node.modifiers.pos);
    }
    if (superclass !== undefined) {
        file.error("inheritance is not allowed", node.name !== undefined ? node.name.end - 1 : node.pos + 1);
    }
    if (interfaces.length === 0) {
        file.error("classes must implement some interface", node.name !== undefined ? node.name.end - 1 : node.pos + 1);
    }
    try {
        for (var _b = __values(node.members), _c = _b.next(); !_c.done; _c = _b.next()) {
            var member = _c.value;
            switch (member.kind) {
                case typescript_1.SyntaxKind.Constructor:
                    if ((0, types_1.assertConstructorDecl)(member)) {
                        lintConstructor(file, member);
                    }
                    break;
                case typescript_1.SyntaxKind.PropertyDeclaration:
                    if ((0, types_1.assertPropertyDecl)(member)) {
                        if (member.initializer === undefined) {
                            if (member.type === undefined) {
                                file.error("field is missing a type", member.name.end - 1);
                            }
                            else {
                                lintType(file, member.type);
                            }
                        }
                        else {
                            if (member.initializer.kind === typescript_1.SyntaxKind.ArrowFunction &&
                                (0, types_1.assertArrowFunction)(member.initializer)) {
                                lintArrowFunction(file, member.initializer, false);
                            }
                            else {
                                lintExpression(file, member.initializer, false);
                            }
                        }
                    }
                    break;
                case typescript_1.SyntaxKind.MethodDeclaration:
                    if ((0, types_1.assertMethodDecl)(member)) {
                        file.error("incorrect method declaration syntax", member.name.end - 1);
                    }
                    break;
                default:
                    file.error("unexpected class member type: ".concat(typescript_1.SyntaxKind[member.kind]), member.pos + 1);
                    break;
            }
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_6) throw e_6.error; }
    }
};
// Performs linting of a constructor declaration.
var lintConstructor = function (file, node) {
    var e_7, _a;
    try {
        for (var _b = __values(node.parameters), _c = _b.next(); !_c.done; _c = _b.next()) {
            var param = _c.value;
            if (param.type === undefined) {
                file.error("parameters must have types", param.name.end - 1);
            }
            else {
                lintType(file, param.type);
            }
        }
    }
    catch (e_7_1) { e_7 = { error: e_7_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_7) throw e_7.error; }
    }
    if (node.body === undefined) {
        file.error("constructor is missing a body", node.name !== undefined ? node.name.end - 1 : node.pos + 1);
    }
    else {
        lintBlock(file, node.body, true);
    }
};
// Performs linting of a *top-level* variable statement.
var lintVariableStmt = function (file, node, topLevel, isConstructor) {
    if (node.modifiers !== undefined &&
        contains(node.modifiers, typescript_1.SyntaxKind.ExportKeyword) &&
        !(0, types_1.hasJSDoc)(node)) {
        file.error("exported declarations must have a JSDoc comment", (node.declarationList.declarations.length === 0) ? node.pos + 1 :
            node.declarationList.declarations[0].name.end - 1);
    }
    lintVariableDecl(file, node.declarationList, topLevel, false, isConstructor);
};
// Performs linting of a variable declaration.
var lintVariableDecl = function (file, list, topLevel, reqInitalizer, isConstructor) {
    if (!file.allowMutation && (list.flags & typescript_1.NodeFlags.Const) === 0) {
        file.error("all variable declarations must be const (no mutation)", (list.declarations.length === 0) ? list.pos + 1 :
            list.declarations[0].name.end - 1);
    }
    if ((list.flags & typescript_1.NodeFlags.Const) === 0 && (list.flags & typescript_1.NodeFlags.Let) === 0) {
        file.error("variables can only be declared with let or const (no var)", (list.declarations.length === 0) ? list.pos + 1 :
            list.declarations[0].name.end - 1);
    }
    if (list.declarations.length !== 1) {
        file.error("expected exactly one variable declaration", list.declarations.pos + 1);
    }
    else {
        var decl = list.declarations[0];
        lintBindingName(file, decl.name);
        if (decl.initializer === undefined) {
            if (reqInitalizer) {
                file.error("must be initialized", decl.name.end - 1);
            }
        }
        else if (topLevel && decl.initializer.kind === typescript_1.SyntaxKind.ArrowFunction) {
            if ((0, types_1.assertArrowFunction)(decl.initializer)) {
                lintArrowFunction(file, decl.initializer, isConstructor);
            }
        }
        else {
            if (decl.type === undefined) {
                if (topLevel) {
                    file.error("top-level variable declarations must have a type", decl.name.end - 1);
                }
            }
            else {
                lintType(file, decl.type);
            }
            lintExpression(file, decl.initializer, isConstructor);
        }
    }
};
// Performs linting of a binding name.
var lintBindingName = function (file, name) {
    var e_8, _a;
    if (name.kind === typescript_1.SyntaxKind.Identifier) {
        // OK
    }
    else if (name.kind === typescript_1.SyntaxKind.ArrayBindingPattern) {
        if ((0, types_1.assertArrayBindingPattern)(name)) {
            try {
                for (var _b = __values(name.elements), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var elem = _c.value;
                    if (elem.kind === typescript_1.SyntaxKind.BindingElement) {
                        if ((0, types_1.assertBindingElement)(elem)) {
                            lintBindingName(file, elem.name);
                        }
                    }
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_8) throw e_8.error; }
            }
        }
    }
    else { // object binding pattern
        file.error("record destructuring is not allowed", name.end - 1);
    }
};
// Determines whether the given array of modifiers contains the kind.
var contains = function (mods, kind) {
    for (var i = 0; i < mods.length; i++) {
        if (mods[i].kind === kind) {
            return true;
        }
    }
    return false;
};
// Performs linting of an arrow function.
var lintArrowFunction = function (file, node, isConstructor) {
    var e_9, _a;
    var paramTypes = [];
    try {
        for (var _b = __values(node.parameters), _c = _b.next(); !_c.done; _c = _b.next()) {
            var param = _c.value;
            if (param.type === undefined) {
                file.error("parameters must have types", param.name.end - 1);
            }
            else if (param.initializer !== undefined) {
                file.error("parameters cannot have default values", param.name.end - 1);
            }
            else {
                lintType(file, param.type);
                paramTypes.push(param.type);
            }
        }
    }
    catch (e_9_1) { e_9 = { error: e_9_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_9) throw e_9.error; }
    }
    if (node.type === undefined) {
        file.error("functions must have a return type", node.parameters.end + 1);
    }
    else {
        lintType(file, node.type);
    }
    // For .ts files: if the two argument types are (Safe)Request and
    // (Safe)Response, then make sure they are both declared as the safe variants.
    if (paramTypes.length === 2) {
        var paramType0 = paramTypes[0];
        var paramType1 = paramTypes[1];
        if (paramType0.kind === typescript_1.SyntaxKind.TypeReference &&
            paramType1.kind === typescript_1.SyntaxKind.TypeReference) {
            if ((0, types_1.assertTypeReference)(paramType0) &&
                (0, types_1.assertTypeReference)(paramType1)) {
                if (paramType0.typeName.kind === typescript_1.SyntaxKind.Identifier &&
                    paramType1.typeName.kind === typescript_1.SyntaxKind.Identifier) {
                    if ((paramType0.typeName.text === "Request" ||
                        paramType0.typeName.text === "SafeRequest") &&
                        (paramType1.typeName.text === "Response" ||
                            paramType1.typeName.text === "SafeResponse") &&
                        file.fileName.endsWith(".ts")) {
                        if (paramType0.typeName.text !== "SafeRequest") {
                            file.error("must use SafeRequest and SafeResponse", paramType0.typeName.end - 1);
                        }
                        if (paramType1.typeName.text !== "SafeResponse") {
                            file.error("must use SafeRequest and SafeResponse", paramType1.typeName.end - 1);
                        }
                    }
                }
            }
        }
    }
    if (node.body.kind === typescript_1.SyntaxKind.Block) {
        if ((0, types_1.assertBlock)(node.body)) {
            lintBlock(file, node.body, isConstructor);
        }
    }
    else {
        lintExpression(file, node.body, isConstructor);
    }
};
// Performs lintinig of a block.
var lintBlock = function (file, node, isConstructor) {
    var e_10, _a;
    try {
        for (var _b = __values(node.statements), _c = _b.next(); !_c.done; _c = _b.next()) {
            var stmt = _c.value;
            lintStatement(file, stmt, isConstructor);
        }
    }
    catch (e_10_1) { e_10 = { error: e_10_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_10) throw e_10.error; }
    }
};
// Lints the given statement inside a function.
var lintStatement = function (file, node, isConstructor) {
    switch (node.kind) {
        case typescript_1.SyntaxKind.EmptyStatement:
        case typescript_1.SyntaxKind.DebuggerStatement:
        case typescript_1.SyntaxKind.ContinueStatement:
        case typescript_1.SyntaxKind.BreakStatement:
            break;
        case typescript_1.SyntaxKind.VariableStatement:
            if ((0, types_1.assertVariableStmt)(node)) {
                lintVariableStmt(file, node, false, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ExpressionStatement:
            if ((0, types_1.assertExpressionStmt)(node)) {
                lintExpressionStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.IfStatement:
            if ((0, types_1.assertIfStmt)(node)) {
                lintIfStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.SwitchStatement:
            if ((0, types_1.assertSwitchStmt)(node)) {
                lintSwitchStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.WhileStatement:
            if ((0, types_1.assertWhileStmt)(node)) {
                lintWhileStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ForStatement:
            if ((0, types_1.assertForStmt)(node)) {
                lintForStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ForOfStatement:
            if ((0, types_1.assertForOfStmt)(node)) {
                lintForOfStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ReturnStatement:
            if ((0, types_1.assertReturnStmt)(node)) {
                lintReturnStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ThrowStatement:
            if ((0, types_1.assertThrowStmt)(node)) {
                lintThrowStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.TryStatement:
            if ((0, types_1.assertTryStmt)(node)) {
                lintTryStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.DoStatement:
            if ((0, types_1.assertDoStmt)(node)) {
                file.error("do statements are not allowed", node.statement.pos - 2);
            }
            break;
        case typescript_1.SyntaxKind.ForInStatement:
            if ((0, types_1.assertForInStmt)(node)) {
                file.error("for-in statements are not allowed", node.expression.pos, node.expression.end);
            }
            break;
        case typescript_1.SyntaxKind.WithStatement:
            if ((0, types_1.assertWithStmt)(node)) {
                file.error("with statements are not allowed", node.expression.pos, node.expression.end);
            }
            break;
        case typescript_1.SyntaxKind.LabeledStatement:
            if ((0, types_1.assertLabeledStmt)(node)) {
                file.error("labeled statements are not allowed", node.label.end - 1);
            }
            break;
        case typescript_1.SyntaxKind.Block:
            if ((0, types_1.assertBlock)(node)) {
                lintBlock(file, node, false);
            }
            break;
        default:
            file.error("unexpected statement type: ".concat(typescript_1.SyntaxKind[node.kind]), node.pos + 1);
    }
};
// Lints the given if statement.
var lintIfStmt = function (file, node, isConstructor) {
    lintExpression(file, node.expression, isConstructor);
    lintStatement(file, node.thenStatement, isConstructor);
    if (node.elseStatement !== undefined) {
        lintStatement(file, node.elseStatement, isConstructor);
    }
};
// Lints the given switch statement.
var lintSwitchStmt = function (file, node, isConstructor) {
    var e_11, _a, e_12, _b;
    lintExpression(file, node.expression, isConstructor);
    try {
        for (var _c = __values(node.caseBlock.clauses), _d = _c.next(); !_d.done; _d = _c.next()) {
            var clause = _d.value;
            if (clause.kind === typescript_1.SyntaxKind.CaseClause) {
                lintExpression(file, clause.expression, isConstructor);
            }
            try {
                for (var _e = (e_12 = void 0, __values(clause.statements)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var stmt = _f.value;
                    lintStatement(file, stmt, isConstructor);
                }
            }
            catch (e_12_1) { e_12 = { error: e_12_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_12) throw e_12.error; }
            }
        }
    }
    catch (e_11_1) { e_11 = { error: e_11_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_11) throw e_11.error; }
    }
};
var INV_RE = /^(\s+|\s*\/\/[^\n]*\n)*\/\/\s+Inv:\s+/;
// Lints the given while statement.
var lintWhileStmt = function (file, node, isConstructor) {
    var text = node.getFullText(file.root);
    if (text.match(INV_RE) === null) {
        var index = text.indexOf("while"); // not perfect, but better than nothing
        file.error("while loops must have an invariant", node.pos + index);
    }
    lintExpression(file, node.expression, isConstructor);
    lintStatement(file, node.statement, isConstructor);
};
// Lints the given for statement.
var lintForStmt = function (file, node, isConstructor) {
    var text = node.getFullText(file.root);
    var index = text.indexOf("for"); // not perfect, but better than nothing
    file.error("for loops are not allowed (only while and for-each)", node.pos + index);
    if (node.initializer !== undefined) {
        if (node.initializer.kind === typescript_1.SyntaxKind.VariableDeclarationList) {
            if ((0, types_1.assertVariableDeclList)(node.initializer)) {
                lintVariableDecl(file, node.initializer, false, true, isConstructor);
            }
        }
        else {
            lintExpression(file, node.initializer, isConstructor);
        }
    }
    if (node.condition !== undefined) {
        lintExpression(file, node.condition, isConstructor);
    }
    if (node.incrementor !== undefined) {
        // This is the one place that we allow ++ and --. Must be of an identifier
        if (isVariableIncDec(node.incrementor)) {
            // OK
        }
        else {
            lintExpression(file, node.incrementor, isConstructor);
        }
    }
    lintStatement(file, node.statement, isConstructor);
};
// Lints the given for-of statement.
var lintForOfStmt = function (file, node, isConstructor) {
    // NOTE: no invariant required
    if (node.initializer.kind === typescript_1.SyntaxKind.VariableDeclarationList) {
        if ((0, types_1.assertVariableDeclList)(node.initializer)) {
            lintVariableDecl(file, node.initializer, false, false, isConstructor);
        }
    }
    else {
        lintExpression(file, node.initializer, isConstructor);
    }
    lintExpression(file, node.expression, isConstructor);
    lintStatement(file, node.statement, isConstructor);
};
// Lints the given return statement.
var lintReturnStmt = function (file, node, isConstructor) {
    if (node.expression !== undefined) {
        lintExpression(file, node.expression, isConstructor);
    }
};
// Lints the given throw statement.
var lintThrowStmt = function (file, node, isConstructor) {
    if (node.expression !== undefined) {
        lintExpression(file, node.expression, isConstructor);
    }
};
// Lints the given try statement.
var lintTryStmt = function (file, node, isConstructor) {
    lintBlock(file, node.tryBlock, isConstructor);
    if (node.catchClause !== undefined) {
        var decl = node.catchClause.variableDeclaration;
        if (decl !== undefined) {
            if (decl.type === undefined) {
                file.error("exception declarations must have a type", decl.name.end - 1);
            }
            else {
                lintType(file, decl.type);
            }
        }
        lintBlock(file, node.catchClause.block, isConstructor);
    }
    if (node.finallyBlock !== undefined) {
        lintBlock(file, node.finallyBlock, isConstructor);
    }
};
// Performs linting of a type.
var lintType = function (file, node, topLevel) {
    var e_13, _a, e_14, _b, e_15, _c, e_16, _d, e_17, _e;
    switch (node.kind) {
        case typescript_1.SyntaxKind.NumberKeyword:
        case typescript_1.SyntaxKind.StringKeyword:
        case typescript_1.SyntaxKind.BooleanKeyword:
        case typescript_1.SyntaxKind.UndefinedKeyword:
        case typescript_1.SyntaxKind.NullKeyword:
        case typescript_1.SyntaxKind.VoidKeyword:
        case typescript_1.SyntaxKind.UnknownKeyword:
        case typescript_1.SyntaxKind.BigIntKeyword:
            // OK
            break;
        case typescript_1.SyntaxKind.LiteralType: // string or integer literal
            // OK
            break;
        case typescript_1.SyntaxKind.AnyKeyword:
            file.error("any type is not allowed", node.pos);
            break;
        case typescript_1.SyntaxKind.TypeReference: // use of a type alias
            if ((0, types_1.assertTypeReference)(node)) {
                if (node.typeArguments !== undefined) {
                    try {
                        for (var _f = __values(node.typeArguments), _g = _f.next(); !_g.done; _g = _f.next()) { // type arguments
                            var arg = _g.value;
                            lintType(file, arg);
                        }
                    }
                    catch (e_13_1) { e_13 = { error: e_13_1 }; }
                    finally {
                        try {
                            if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
                        }
                        finally { if (e_13) throw e_13.error; }
                    }
                }
            }
            break;
        case typescript_1.SyntaxKind.TypeOperator:
            if ((0, types_1.assertTypeOperator)(node)) {
                lintType(file, node.type);
            }
            break;
        case typescript_1.SyntaxKind.TupleType:
            if ((0, types_1.assertTupleType)(node)) {
                for (var i = 0; i < node.elements.length; i++) {
                    lintType(file, node.elements[i]);
                }
            }
            break;
        case typescript_1.SyntaxKind.UnionType:
            if ((0, types_1.assertUnionType)(node)) {
                try {
                    for (var _h = __values(node.types), _j = _h.next(); !_j.done; _j = _h.next()) {
                        var typ = _j.value;
                        lintType(file, typ);
                    }
                }
                catch (e_14_1) { e_14 = { error: e_14_1 }; }
                finally {
                    try {
                        if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
                    }
                    finally { if (e_14) throw e_14.error; }
                }
            }
            break;
        case typescript_1.SyntaxKind.ArrayType:
            if ((0, types_1.assertArrayType)(node)) {
                lintType(file, node.elementType);
            }
            break;
        case typescript_1.SyntaxKind.TypeLiteral: // record type
            if ((0, types_1.assertTypeLiteral)(node)) {
                try {
                    for (var _k = __values(node.members), _l = _k.next(); !_l.done; _l = _k.next()) {
                        var member = _l.value;
                        if (member.kind === typescript_1.SyntaxKind.PropertySignature) {
                            if ((0, types_1.assertPropertySignature)(member)) {
                                if (member.type === undefined) {
                                    file.error("fields of records must have a type", member.name.end - 1);
                                }
                                else {
                                    lintType(file, member.type);
                                }
                            }
                        }
                        else {
                            file.error("unexpected type literal member: ".concat(typescript_1.SyntaxKind[member.kind]), member.pos + 1);
                        }
                    }
                }
                catch (e_15_1) { e_15 = { error: e_15_1 }; }
                finally {
                    try {
                        if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
                    }
                    finally { if (e_15) throw e_15.error; }
                }
            }
            break;
        case typescript_1.SyntaxKind.FunctionType:
            if ((0, types_1.assertFunctionType)(node)) {
                try {
                    for (var _m = __values(node.parameters), _o = _m.next(); !_o.done; _o = _m.next()) {
                        var param = _o.value;
                        if (param.type === undefined) {
                            file.error("parameters of functions must have a type", param.name.end - 1);
                        }
                        else {
                            lintType(file, param.type);
                        }
                    }
                }
                catch (e_16_1) { e_16 = { error: e_16_1 }; }
                finally {
                    try {
                        if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
                    }
                    finally { if (e_16) throw e_16.error; }
                }
                lintType(file, node.type);
            }
            break;
        case typescript_1.SyntaxKind.TypePredicate:
            if ((0, types_1.assertTypePredicate)(node)) {
                if (node.type !== undefined) {
                    lintType(file, node.type);
                }
            }
            break;
        case typescript_1.SyntaxKind.IntersectionType:
            if ((0, types_1.assertIntersectionType)(node)) {
                if (!topLevel) {
                    file.error("intersection types are only allowed in top-level alias declarations", node.end - 1);
                }
                else {
                    try {
                        for (var _p = __values(node.types), _q = _p.next(); !_q.done; _q = _p.next()) {
                            var typ = _q.value;
                            lintType(file, typ);
                        }
                    }
                    catch (e_17_1) { e_17 = { error: e_17_1 }; }
                    finally {
                        try {
                            if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
                        }
                        finally { if (e_17) throw e_17.error; }
                    }
                }
            }
            break;
        default:
            file.error("unexpected type: ".concat(typescript_1.SyntaxKind[node.kind]), node.pos + 1);
            break;
    }
};
// Performs linting of an expression statement.
var lintExpressionStmt = function (file, node, isConstructor) {
    lintExpression(file, node.expression, isConstructor);
};
// Performs linting of an expression.
var lintExpression = function (file, node, isConstructor) {
    var e_18, _a, e_19, _b, e_20, _c, e_21, _d, e_22, _e;
    switch (node.kind) {
        case typescript_1.SyntaxKind.Identifier:
        case typescript_1.SyntaxKind.NumericLiteral:
        case typescript_1.SyntaxKind.StringLiteral:
        case typescript_1.SyntaxKind.TrueKeyword:
        case typescript_1.SyntaxKind.FalseKeyword:
        case typescript_1.SyntaxKind.NullKeyword:
        case typescript_1.SyntaxKind.ThisKeyword:
        case typescript_1.SyntaxKind.SuperKeyword:
        case typescript_1.SyntaxKind.BigIntLiteral:
            // OK
            break;
        case typescript_1.SyntaxKind.ParenthesizedExpression:
            if ((0, types_1.assertParenthesizedExpr)(node)) {
                lintExpression(file, node.expression, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.PrefixUnaryExpression:
            if ((0, types_1.assertPrefixUnaryExpr)(node)) {
                if (node.operator === typescript_1.SyntaxKind.PlusPlusToken || node.operator === typescript_1.SyntaxKind.MinusMinusToken) {
                    file.error("++ and -- are not allowed", node.operand.pos - 2);
                }
                lintExpression(file, node.operand, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.PostfixUnaryExpression:
            if ((0, types_1.assertPostfixUnaryExpr)(node)) {
                file.error("++ and -- are not allowed", node.operand.end + 2);
            }
            break;
        case typescript_1.SyntaxKind.BinaryExpression:
            if ((0, types_1.assertBinaryExpr)(node)) {
                lintBinaryExpr(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ConditionalExpression:
            if ((0, types_1.assertConditionalExpr)(node)) {
                lintExpression(file, node.condition, isConstructor);
                lintExpression(file, node.whenTrue, isConstructor);
                lintExpression(file, node.whenFalse, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.TypeOfExpression:
            if ((0, types_1.assertTypeOfExpr)(node)) {
                lintExpression(file, node.expression, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.PropertyAccessExpression:
            if ((0, types_1.assertPropertyAccessExpr)(node)) {
                lintExpression(file, node.expression, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ElementAccessExpression:
            if ((0, types_1.assertElementAccessExpr)(node)) {
                lintExpression(file, node.argumentExpression, isConstructor);
                lintExpression(file, node.expression, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.NewExpression:
            if ((0, types_1.assertNewExpr)(node)) {
                if (node.expression.kind !== typescript_1.SyntaxKind.Identifier) {
                    file.error("expecting an identifier after 'new'", node.expression.pos + 1);
                }
                if (node.typeArguments !== undefined) {
                    try {
                        for (var _f = __values(node.typeArguments), _g = _f.next(); !_g.done; _g = _f.next()) {
                            var arg = _g.value;
                            lintType(file, arg);
                        }
                    }
                    catch (e_18_1) { e_18 = { error: e_18_1 }; }
                    finally {
                        try {
                            if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
                        }
                        finally { if (e_18) throw e_18.error; }
                    }
                }
                if (node.arguments !== undefined) {
                    try {
                        for (var _h = __values(node.arguments), _j = _h.next(); !_j.done; _j = _h.next()) {
                            var arg = _j.value;
                            lintExpression(file, arg, isConstructor);
                        }
                    }
                    catch (e_19_1) { e_19 = { error: e_19_1 }; }
                    finally {
                        try {
                            if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
                        }
                        finally { if (e_19) throw e_19.error; }
                    }
                }
            }
            break;
        case typescript_1.SyntaxKind.CallExpression:
            if ((0, types_1.assertCallExpr)(node)) {
                lintCallExpr(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.TemplateExpression:
            if ((0, types_1.assertTemplateExpr)(node)) {
                try {
                    for (var _k = __values(node.templateSpans), _l = _k.next(); !_l.done; _l = _k.next()) {
                        var span = _l.value;
                        lintExpression(file, span.expression, isConstructor);
                    }
                }
                catch (e_20_1) { e_20 = { error: e_20_1 }; }
                finally {
                    try {
                        if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
                    }
                    finally { if (e_20) throw e_20.error; }
                }
            }
            break;
        case typescript_1.SyntaxKind.ArrayLiteralExpression:
            if ((0, types_1.assertArrayLiteralExpr)(node)) {
                try {
                    for (var _m = __values(node.elements), _o = _m.next(); !_o.done; _o = _m.next()) {
                        var elem = _o.value;
                        lintExpression(file, elem, isConstructor);
                    }
                }
                catch (e_21_1) { e_21 = { error: e_21_1 }; }
                finally {
                    try {
                        if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
                    }
                    finally { if (e_21) throw e_21.error; }
                }
            }
            break;
        case typescript_1.SyntaxKind.ObjectLiteralExpression:
            if ((0, types_1.assertObjectLiteralExpr)(node)) {
                try {
                    for (var _p = __values(node.properties), _q = _p.next(); !_q.done; _q = _p.next()) {
                        var elem = _q.value;
                        lintObjectLiteralProperty(file, elem, isConstructor);
                    }
                }
                catch (e_22_1) { e_22 = { error: e_22_1 }; }
                finally {
                    try {
                        if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
                    }
                    finally { if (e_22) throw e_22.error; }
                }
            }
            break;
        case typescript_1.SyntaxKind.SpreadElement:
            file.error("spread expressions are not allowed", node.pos + 1);
            break;
        case typescript_1.SyntaxKind.JsxElement:
            if ((0, types_1.assertJsxElem)(node)) {
                lintJsxElem(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.JsxSelfClosingElement:
            if ((0, types_1.assertJsxSelfClosingElem)(node)) {
                lintJsxSelfClosingElem(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.JsxFragment:
            if ((0, types_1.assertJsxFragment)(node)) {
                lintJsxFragment(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ArrowFunction:
            if ((0, types_1.assertArrowFunction)(node)) {
                if (node.body.kind === typescript_1.SyntaxKind.Block && (0, types_1.assertBlock)(node.body)) {
                    file.error("only simple function expressions are allowed (not blocks)", node.parameters.pos, node.body.end);
                }
                else {
                    var text = node.getFullText(file.root).trim();
                    if (text.indexOf("\n") !== -1 || text.length > 100) {
                        file.error("only simple function expressions are allowed", node.parameters.pos, node.body.end);
                    }
                    else {
                        lintExpression(file, node.body, isConstructor);
                    }
                }
            }
            break;
        case typescript_1.SyntaxKind.FunctionExpression:
            if (!isTestFile(file)) {
                file.error("function expressions are not allowed here", node.pos, node.end);
            }
            else {
                if ((0, types_1.assertFunctionExpression)(node)) {
                    lintBlock(file, node.body, isConstructor);
                }
            }
            break;
        case typescript_1.SyntaxKind.NonNullExpression:
            if ((0, types_1.assertNonNullExpr)(node)) {
                file.error("non-null assertions are not allowed", node.end);
            }
            break;
        case typescript_1.SyntaxKind.ClassExpression:
            file.error("class expressions are not allowed", node.pos + 1);
            break;
        case typescript_1.SyntaxKind.AsExpression:
            file.error("type casts are not allowed", node.pos, node.end);
            break;
        case typescript_1.SyntaxKind.DeleteExpression:
            file.error("delete operator is not allowed", node.pos, node.end);
            break;
        case typescript_1.SyntaxKind.VoidExpression:
            file.error("void expression is not allowed", node.pos, node.end);
            break;
        case typescript_1.SyntaxKind.AwaitExpression:
            file.error("await expression is not allowed", node.pos, node.end);
            break;
        case typescript_1.SyntaxKind.YieldExpression:
            file.error("yield expression is not allowed", node.pos, node.end);
            break;
        case typescript_1.SyntaxKind.FirstTemplateToken:
            file.error("not a template string literal", node.pos, node.end);
            break;
        default:
            file.error("unexpected expression type: ".concat(typescript_1.SyntaxKind[node.kind]), node.pos, node.end);
            break;
    }
};
// Operators that perform assignments
var assignmentOperators = new Set([
    typescript_1.SyntaxKind.EqualsToken, typescript_1.SyntaxKind.PlusEqualsToken,
    typescript_1.SyntaxKind.MinusEqualsToken, typescript_1.SyntaxKind.AsteriskEqualsToken,
    typescript_1.SyntaxKind.AsteriskAsteriskEqualsToken, typescript_1.SyntaxKind.SlashEqualsToken,
    typescript_1.SyntaxKind.PercentEqualsToken, typescript_1.SyntaxKind.LessThanLessThanEqualsToken,
    typescript_1.SyntaxKind.GreaterThanGreaterThanEqualsToken,
    typescript_1.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken,
    typescript_1.SyntaxKind.AmpersandEqualsToken, typescript_1.SyntaxKind.BarEqualsToken,
    typescript_1.SyntaxKind.BarBarEqualsToken, typescript_1.SyntaxKind.AmpersandAmpersandEqualsToken,
    typescript_1.SyntaxKind.QuestionQuestionEqualsToken, typescript_1.SyntaxKind.CaretEqualsToken
]);
// Operators that perform boolean operations.
var booleanOperators = new Set([
    typescript_1.SyntaxKind.AmpersandAmpersandToken, typescript_1.SyntaxKind.BarBarToken
]);
// Operators that could be the root of a JSX subexpression.
var jsxOperators = new Set([
    typescript_1.SyntaxKind.JsxElement, typescript_1.SyntaxKind.JsxSelfClosingElement,
    typescript_1.SyntaxKind.JsxFragment
]);
// Perform linting of a binary expression.
var lintBinaryExpr = function (file, node, isConstructor) {
    lintExpression(file, node.left, isConstructor);
    lintExpression(file, node.right, isConstructor);
    if (booleanOperators.has(node.operatorToken.kind)) {
        if (jsxOperators.has(node.left.kind) || jsxOperators.has(node.right.kind)) {
            file.error("logical operators are not allowed on JSX elements", node.left.end, node.operatorToken.end);
        }
    }
    if (assignmentOperators.has(node.operatorToken.kind)) {
        if (file.allowMutation) {
            // okay
        }
        else if (isConstructor &&
            node.left.kind === typescript_1.SyntaxKind.PropertyAccessExpression &&
            (0, types_1.assertPropertyAccessExpr)(node.left) &&
            node.left.expression.kind === typescript_1.SyntaxKind.ThisKeyword) {
            // okay
        }
        else {
            file.error("mutation is not allowed", node.left.end, node.right.pos);
        }
    }
};
// Perform linting of a call expression.
var lintCallExpr = function (file, node, isConstructor) {
    var e_23, _a, e_24, _b;
    lintExpression(file, node.expression, isConstructor);
    if (node.typeArguments !== undefined) {
        try {
            for (var _c = __values(node.typeArguments), _d = _c.next(); !_d.done; _d = _c.next()) {
                var arg = _d.value;
                lintType(file, arg);
            }
        }
        catch (e_23_1) { e_23 = { error: e_23_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_23) throw e_23.error; }
        }
    }
    if (node.expression.kind === typescript_1.SyntaxKind.Identifier &&
        (0, types_1.assertIdentifier)(node.expression)) {
        var funcName = node.expression.text;
        if (funcName === "fetch") {
            lintFetch(file, node);
        }
    }
    else if (node.expression.kind === typescript_1.SyntaxKind.PropertyAccessExpression &&
        (0, types_1.assertPropertyAccessExpr)(node.expression) &&
        node.expression.name.kind === typescript_1.SyntaxKind.Identifier &&
        (0, types_1.assertIdentifier)(node.expression.name)) {
        var methodName = node.expression.name.text;
        if ((methodName === "json" || methodName === "text") &&
            node.arguments.length === 1) {
            file.error("call to .".concat(methodName, " is not allowed"), node.expression.name.end - 1);
        }
    }
    if (node.arguments !== undefined) {
        try {
            for (var _e = __values(node.arguments), _f = _e.next(); !_f.done; _f = _e.next()) {
                var arg = _f.value;
                lintExpression(file, arg, isConstructor);
            }
        }
        catch (e_24_1) { e_24 = { error: e_24_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_24) throw e_24.error; }
        }
    }
};
// Performs linting of a property within an object literal expression.
var lintObjectLiteralProperty = function (file, elem, isConstructor) {
    switch (elem.kind) {
        case typescript_1.SyntaxKind.PropertyAssignment:
            if ((0, types_1.assertPropertyAssignment)(elem)) {
                lintExpression(file, elem.initializer, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ShorthandPropertyAssignment:
            // OK
            break;
        case typescript_1.SyntaxKind.SpreadAssignment:
            file.error("spread expressions are not allowed", elem.pos, elem.end);
            break;
        case typescript_1.SyntaxKind.MethodDeclaration:
            file.error("method declarations are not allowed", elem.pos, elem.end);
            break;
        default:
            file.error("unexpected property type: ".concat(typescript_1.SyntaxKind[elem.kind]), elem.pos, elem.end);
            break;
    }
};
// Performs linting of a JSX element.
var lintJsxElem = function (file, node, isConstructor) {
    var e_25, _a;
    lintJsxAttributes(file, node.openingElement.attributes, isConstructor);
    try {
        for (var _b = __values(node.children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            lintJsxChild(file, child, isConstructor);
        }
    }
    catch (e_25_1) { e_25 = { error: e_25_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_25) throw e_25.error; }
    }
};
// Performs linting of a JSX self-closing element.
var lintJsxSelfClosingElem = function (file, node, isConstructor) {
    lintJsxAttributes(file, node.attributes, isConstructor);
};
// Performs linting of a JSX element.
var lintJsxAttributes = function (file, attributes, isConstructor) {
    var e_26, _a;
    try {
        for (var _b = __values(attributes.properties), _c = _b.next(); !_c.done; _c = _b.next()) {
            var attr = _c.value;
            if (attr.kind !== typescript_1.SyntaxKind.JsxAttribute) {
                file.error("spread attributes are not allowed", attr.pos, attr.end);
            }
            else if ((0, types_1.assertJsxAttribute)(attr)) {
                if (attr.initializer !== undefined) {
                    if (attr.initializer.kind === typescript_1.SyntaxKind.StringLiteral) {
                        // OK
                    }
                    else if (attr.initializer.kind === typescript_1.SyntaxKind.JsxExpression &&
                        (0, types_1.assertJsxExpr)(attr.initializer)) {
                        var expr = attr.initializer.expression;
                        if (expr !== undefined) {
                            lintExpression(file, expr, isConstructor);
                        }
                    }
                    else {
                        file.error("unexpected attribute type: ".concat(typescript_1.SyntaxKind[attr.initializer.kind]), attr.pos, attr.end);
                    }
                }
            }
        }
    }
    catch (e_26_1) { e_26 = { error: e_26_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_26) throw e_26.error; }
    }
};
// Performs linting of a JSX fragment.
var lintJsxFragment = function (file, node, isConstructor) {
    var e_27, _a;
    try {
        for (var _b = __values(node.children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            lintJsxChild(file, child, isConstructor);
        }
    }
    catch (e_27_1) { e_27 = { error: e_27_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_27) throw e_27.error; }
    }
};
// Performs linting of a JSX child.
var lintJsxChild = function (file, child, isConstructor) {
    switch (child.kind) {
        case typescript_1.SyntaxKind.JsxText:
            // OK
            break;
        case typescript_1.SyntaxKind.JsxExpression:
            if ((0, types_1.assertJsxExpr)(child)) {
                if (child.expression !== undefined) {
                    lintExpression(file, child.expression, isConstructor);
                }
            }
            break;
        case typescript_1.SyntaxKind.JsxElement:
            lintJsxElem(file, child, isConstructor);
            break;
        case typescript_1.SyntaxKind.JsxSelfClosingElement:
            lintJsxSelfClosingElem(file, child, isConstructor);
            break;
        case typescript_1.SyntaxKind.JsxFragment:
            lintJsxFragment(file, child, isConstructor);
            break;
        default:
            throw new Error("impossible");
    }
};
// Performs linting of a call to fetch.
var lintFetch = function (file, node) {
    if (node.arguments.length === 1) {
        // OK
    }
    else if (node.arguments.length === 2) {
        var arg = node.arguments[1];
        if (arg.kind !== typescript_1.SyntaxKind.ObjectLiteralExpression) {
            file.error("second argument to fetch should be a record", arg.pos, arg.end);
        }
        else if ((0, types_1.assertObjectLiteralExpr)(arg)) {
            var fields = getFields(arg);
            var method = fields.get("method");
            if (method === undefined) {
                file.error("missing 'method' field in the call to fetch", arg.pos, arg.end);
            }
            else if (method.kind !== typescript_1.SyntaxKind.StringLiteral ||
                (0, types_1.assertStringLiteral)(method) && (method.text !== "POST")) {
                file.error("'method' is only required for POST requests", method.pos, method.end);
            }
            var body = fields.get("body");
            if (body === undefined) {
                file.error("missing 'body' field in the call to fetch", arg.pos, arg.end);
            }
            var headers = fields.get("headers");
            if (headers === undefined) {
                file.error("missing 'headers' field in the call to fetch", arg.pos, arg.end);
            }
            else if (headers.kind === typescript_1.SyntaxKind.ObjectLiteralExpression &&
                (0, types_1.assertObjectLiteralExpr)(headers)) {
                var headerFields = getFields(headers);
                var contentType = headerFields.get("Content-Type");
                if (contentType === undefined) {
                    file.error("missing 'Content-Type' header in the call to fetch", arg.pos, arg.end);
                }
                else if (contentType.kind !== typescript_1.SyntaxKind.StringLiteral ||
                    (0, types_1.assertStringLiteral)(contentType) && (contentType.text !== "application/json")) {
                    file.error("'Content-Type' header should be 'application/json'", arg.pos, arg.end);
                }
            }
            else {
                file.error("'headers' should be an object literal", arg.pos, arg.end);
            }
        }
    }
    else {
        file.error("expecting one or two arguments to fetch", node.arguments.pos, node.arguments.end);
    }
};
// Returns a map from constant field names to their value expressions in an
// object literal expression (non-constant fields are ignored).
var getFields = function (expr) {
    var e_28, _a;
    var fields = new Map();
    try {
        for (var _b = __values(expr.properties), _c = _b.next(); !_c.done; _c = _b.next()) {
            var prop = _c.value;
            if (prop.kind === typescript_1.SyntaxKind.PropertyAssignment &&
                (0, types_1.assertPropertyAssignment)(prop)) {
                var name_2 = getName(prop.name);
                if (name_2 !== undefined) {
                    fields.set(name_2, prop.initializer);
                }
            }
        }
    }
    catch (e_28_1) { e_28 = { error: e_28_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_28) throw e_28.error; }
    }
    return fields;
};
// Returns the name of a property or undefined if not unedrstood.
var getName = function (name) {
    if (name.kind === typescript_1.SyntaxKind.Identifier && (0, types_1.assertIdentifier)(name)) {
        return name.text;
    }
    else if (name.kind === typescript_1.SyntaxKind.StringLiteral && (0, types_1.assertStringLiteral)(name)) {
        return name.text;
    }
    else {
        return undefined;
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGludGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2xpbnRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLHlDQVMrRTtBQUMvRSxpQ0FrQndGO0FBbUJ4RixxQ0FBcUM7QUFDckMsSUFBTSxVQUFVLEdBQUcsVUFBQyxJQUFZO0lBQzlCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDO1FBQ2xDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQzdDLENBQUMsQ0FBQztBQUdGLDhEQUE4RDtBQUM5RCxJQUFNLGdCQUFnQixHQUFHLFVBQUMsSUFBZ0I7SUFDeEMsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLHVCQUFVLENBQUMscUJBQXFCLEVBQUU7UUFDbEQsSUFBSSxJQUFBLDZCQUFxQixFQUFDLElBQUksQ0FBQyxFQUFFO1lBQy9CLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxLQUFLLHVCQUFVLENBQUMsYUFBYTtnQkFDMUMsSUFBSSxDQUFDLFFBQVEsS0FBSyx1QkFBVSxDQUFDLGVBQWUsQ0FBQztnQkFDOUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEtBQUssdUJBQVUsQ0FBQyxVQUFVLENBQUM7U0FDcEQ7S0FDRjtTQUFNLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyx1QkFBVSxDQUFDLHNCQUFzQixFQUFFO1FBQzFELElBQUksSUFBQSw4QkFBc0IsRUFBQyxJQUFJLENBQUMsRUFBRTtZQUNoQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsS0FBSyx1QkFBVSxDQUFDLGFBQWE7Z0JBQzFDLElBQUksQ0FBQyxRQUFRLEtBQUssdUJBQVUsQ0FBQyxlQUFlLENBQUM7Z0JBQzlDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxLQUFLLHVCQUFVLENBQUMsVUFBVSxDQUFDO1NBQ3BEO0tBQ0Y7SUFDRCxPQUFPLEtBQUssQ0FB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